{"meta":{"title":"张劲航的博客","subtitle":"生于南蛮，而不甘荒裔","description":null,"author":"John Zhang","url":"http://johnzhang.coding.io"},"pages":[],"posts":[{"title":"Tomcat配置https自签名证书，解决IOS7.1以上plist方式安装应用无法连接问题","slug":"the-tomcat-configuration-https-self-signed-certificate","date":"2015-04-21T16:00:00.000Z","updated":"2016-10-10T09:11:28.000Z","comments":true,"path":"2015/04/22/the-tomcat-configuration-https-self-signed-certificate/","link":"","permalink":"http://johnzhang.coding.io/2015/04/22/the-tomcat-configuration-https-self-signed-certificate/","excerpt":"","text":"##场景企业应用管理系统，通过管理系统上传IOS应用安装文件（ipa文件），并生成plist文件，实现App的发布；管理系统的iPhone客户端通过请求生成好的plist文件便可安装IOS应用。 ##问题在开发完成后，iPhone客户端只要让Safari浏览器这样访问plist文件，系统便会提示安装应用，但iPhone客户端提示无法连接。1itms-services://?action=download-manifest&amp;url=https://192.168.1.113/foo/xxx/iphone.plist ##思路我们知道在IOS 7.1以上，plist文件的下载地址必须是HTTPS的，所以作为一个Java后台程序猿，自然在网上随便搜了一个证书生成命令，配置好了Tomcat的SSL，便认为一切应该顺利通过。 plist文件的HTTPS访问地址：1https://192.168.1.113/foo/xxx/iphone.plist 经过确认，plist文件格式正确无误。其实，提示无法连接，这显然跟HTTPS有关。 验证HTTPS是否正确配置如何验证呢？找一个HTTPS配置好并确定可用的服务器，把plist文件放上去不就行了，立马就想到了七牛云存储，谁知道选好文件，提示我“不支持该文件类型，请升级为标准用户”。 然后我就想到了用代码托管网站试试： git.oschina.net 没有的话，注册一个账号，创建一个公开项目，然后在线添加plist文件把文件内容粘贴进来（点 + 添加文件），提交保存，最后打开查看，入下图，点击“原始数据”按钮，可获得该文件的访问链接。 好了，用iPhone的Safari浏览器以安装方式的URL打开，Bingo !!! 终于提示是否安装了，这意味着我本地开发配置的HTTPS是有问题的。 （悄悄的说一句，其实我先尝试了coding.net，安装方式访问plist，仍然提示无法连接，想试的童鞋可以再试试看行不行。） 正确生成证书HTTPS的问题在哪？除了证书，我想不到别的。 一番搜索，我决定用openSSL来生成证书试试： 如果你用的是Windows系统，上网搜一下“openssl for windows”； 找到各版本下载列表后，看自己操作系统是32位还是64位下载对应的版本； 如果没有安装Visual C++ 2008 Redistributables的情况下安装openSSL会有警告的； 不确定的情况下，就先执行openSSL的安装看有没有警告吧。 这些都难不到我们的，安装完了就开始生成证书 先创建文件夹准备存放证书，这里比如是C:\\ca\\ 运行cmd，先切到openSSL安装目录地下的bin目录：1cd C:\\OpenSSL-Win64\\bin 创建根证书1、 创建制作根证书的私钥文件myCA.key 1openssl genrsa -out c:\\ca\\myCA.key 2048 2、创建根证书myCA.cer，机构名称为My Custom CA1openssl req -new -x509 -key C:\\ca\\myCA.key -out C:\\ca\\myCA.cer -days 730 –subj /CN=\"My CustomCA\" ####创建自签名SSL证书（叶证书）1、创建一个私钥server.key1openssl genrsa -out C:\\ca\\server.key 2048 2、创建CSR，服务器ip地址如：192.168.1.113，输出文件为server.req1openssl req -new -out C:\\ca\\server.req -key C:\\ca\\server.key -subj /CN=192.168.1.113 3、用CSR去创建SSL证书，有效期为100年，输出文件为server.cer，序号文件为server.serial（撤销证书时使用）1openssl x509 -req -in C:\\ca\\server.req -out C:\\ca\\server.cer -CAkey C:\\ca\\myCA.key -CA C:\\ca\\myCA.cer -days 36500 -CAcreateserial -CAserial C:\\ca\\server.serial 4、将.key 和.cer 文件导出为.p12 证书，需要输入两次证书密码。这里我们假设密码为123456。输出文件名为server.p121openssl pkcs12 -export -in C:\\ca\\server.cer -inkey C:\\ca\\server.key -out C:\\ca\\server.p12 -name \"server\" 5、用keytool将.p12 文件导入到java keystore 中，这里srcstorepass后面的123456为server.p12的密码，deststorepass后的12356为keystore的密码。1keytool -importkeystore -v -srckeystore C:\\ca\\server.p12 -srcstoretype pkcs12 -srcstorepass 123456 -destkeystore C:\\ca\\server.keystore -deststoretype jks -deststorepass 123456 ####使用SSL证书打开Tomcat安装目录，修改conf目录下的server.xml12345&lt;Connector SSLEnabled=\"true\" protocol=\"org.apache.coyote.http11.Http11Protocol\" scheme=\"https\" secure=\"true\" sslProtocol=\"TLS\" keystoreFile=\"C:/ca/server.keystore\" keystorePass=\"123456\" maxThreads=\"150\" port=\"443\" clientAuth=\"false\" /&gt; 这里设置了HTTPS访问端口为443（默认端口，可不输入），启动Tomcat，访问看是否可用1https://192.168.1.113/foo/ ####iPhone安装证书将我们生成的C:\\ca\\myCA.cer放到Tomcat部署的应用中，供iPhone访问下载1https://192.168.1.113/foo/myCA.cer 当然，这里可以不用HTTPS的方式访问下载也可以 iPhone打开Safari浏览器访问下载地址，安装好证书，就可以再试试访问plist安装了：1itms-services://?action=download-manifest&amp;url=https://192.168.1.113/foo/xxx/iphone.plist 提示是否安装就说明成功了。","categories":[{"name":"javaee","slug":"javaee","permalink":"http://johnzhang.coding.io/categories/javaee/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://johnzhang.coding.io/tags/tomcat/"},{"name":"https","slug":"https","permalink":"http://johnzhang.coding.io/tags/https/"},{"name":"ios","slug":"ios","permalink":"http://johnzhang.coding.io/tags/ios/"},{"name":"plist","slug":"plist","permalink":"http://johnzhang.coding.io/tags/plist/"},{"name":"inhouse","slug":"inhouse","permalink":"http://johnzhang.coding.io/tags/inhouse/"},{"name":"openssl","slug":"openssl","permalink":"http://johnzhang.coding.io/tags/openssl/"}],"keywords":[{"name":"javaee","slug":"javaee","permalink":"http://johnzhang.coding.io/categories/javaee/"}]},{"title":"为什么在JSP中通过EL表达式无法显示Model中的数据","slug":"model-value-is-not-displayed-in-jsp-via-el","date":"2015-02-08T16:00:00.000Z","updated":"2016-10-10T09:11:28.000Z","comments":true,"path":"2015/02/09/model-value-is-not-displayed-in-jsp-via-el/","link":"","permalink":"http://johnzhang.coding.io/2015/02/09/model-value-is-not-displayed-in-jsp-via-el/","excerpt":"","text":"在Spring MVC的开发过程中，我们将一个值存放到Model中然后在JSP页面中通过EL表达式显示出来，就像这样${name}，但是当运行起来通过浏览器查看效果时，它竟然原样输出了${name}，EL表达式似乎根本就没有工作。 那么问题来了先看看代码有没有问题： Spring’s Controller1234567891011121314import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class ChatController &#123; @RequestMapping(\"/foo\") public String foo(String name, Model model)&#123; model.addAttribute(\"name\", name); return \"hello\"; &#125;&#125; hello.jsp12345678&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello $&#123;name&#125; !&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 代码没有什么问题，这感觉就一个字：这不科学！ 解决办法1、在JSP中通过JSP指令关掉EL忽略解析123456789&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page isELIgnored=\"false\" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello $&#123;name&#125; !&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 打开浏览器看看，嗯，解析并得到了想要的结果，但你肯定会纳闷了，以前开发过程中也没去设置也照样好好的啊？那接着往下看 2、在web.xml中关闭EL忽略解析123456789101112&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;false&lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 当然，跟前一种方式对比，也就是全局控制和局部控制的差别，可以解决问题，但是到底是什么原因呢？ 3、web.xml文档声明惹的祸这是大多数 SpringMVC 实践过程中通常会遇到的问题，事实上它是由于web.xml采用了旧的文档声明(Servlet 2.3 / JSP 1.2)导致的（此时EL表达式忽略不解析默认为开启），如下，在你的web.xml文件可能是这个样子， 1234567&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; ...&lt;/web-app&gt; 你可以打开 DTD 对应链接，下载后打开查看37行的位置12345678910&lt;!--This is the XML DTD for the Servlet 2.3 deployment descriptor.All Servlet 2.3 deployment descriptors must include a DOCTYPEof the following form: &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;--&gt; 那么现在，采用 Servlet 2.3 以上的文档声明，就可以不用再多写别的配置（方法1或方法2）了，比如一个2.4的应该像这样：1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_4.xsd\" version=\"2.4\"&gt; ...&lt;/web-app&gt; EL表达式是不是乖乖的工作了？好了，继续早该完成的工作吧。","categories":[{"name":"javaee","slug":"javaee","permalink":"http://johnzhang.coding.io/categories/javaee/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://johnzhang.coding.io/tags/jsp/"},{"name":"el表达式","slug":"el表达式","permalink":"http://johnzhang.coding.io/tags/el表达式/"},{"name":"spring mvc","slug":"spring-mvc","permalink":"http://johnzhang.coding.io/tags/spring-mvc/"}],"keywords":[{"name":"javaee","slug":"javaee","permalink":"http://johnzhang.coding.io/categories/javaee/"}]}]}